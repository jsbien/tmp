import os
import subprocess
import sys
import hashlib
import json

# Script version
SCRIPT_VERSION = "1.7"

# Exiv2-style sorting order for TIFF and EXIF tags
TIFF_TAGS = [
    "256", "257", "258", "259", "262", "270", "271", "272", "274", "277", "282", "283", "284", "296",
    "301", "305", "306", "315", "318", "319", "529", "530", "531", "532", "18246", "33432"
]
EXIF_TAGS = [
    "36864", "40960", "40961", "37121", "37122", "40962", "40963", "37510", "40964", "36867", "36868",
    "33434", "33437", "34850", "34852", "34855", "34856", "37377", "37378", "37379", "37380", "37381",
    "37382", "37383", "37384", "37385", "37386", "37396", "41483", "41484", "41486", "41487", "41488",
    "41492", "41493", "41495", "41728", "41729", "41730", "41985", "41986", "41987", "41988", "41989",
    "41990", "41991", "41992", "41993", "41994", "41995", "41996", "42016"
]

def extract_exif_binary(image_path, tag_list):
    """Extracts binary EXIF/TIFF metadata based on tag list."""
    try:
        result = subprocess.run(
            ["exiftool", "-b", "-j"] + [f"-{tag}" for tag in tag_list] + [image_path],
            capture_output=True, text=True, check=True
        )
        exif_data = json.loads(result.stdout)[0]

        tag_values = []
        for tag in tag_list:
            value = exif_data.get(tag, None)
            if value is not None:
                tag_values.append(value.encode() if isinstance(value, str) else bytes(value))
            else:
                tag_values.append(b"")  # Include empty fields for Exiv2 consistency

        return tag_values

    except (subprocess.CalledProcessError, IndexError, json.JSONDecodeError):
        return [b""] * len(tag_list)  # Return empty list if metadata is missing

def compute_native_digest(image_path, tiff_only=False):
    """Computes NativeDigest in the format 'tagID1,tagID2,...;MD5_HASH'."""
    tag_list = TIFF_TAGS if tiff_only else EXIF_TAGS
    tag_values = extract_exif_binary(image_path, tag_list)

    # Compute MD5 hash of concatenated binary values
    md5_hash = hashlib.md5(b"".join(tag_values)).hexdigest().upper()

    return f"{','.join(tag_list)};{md5_hash}" if tag_list else f";{md5_hash}"

def generate_xmp_files(image_dir):
    """Creates Geeqie-compatible XMP files for PNG images."""
    if not os.path.exists(image_dir):
        print(f"Error: Directory {image_dir} does not exist.")
        sys.exit(1)

    for filename in os.listdir(image_dir):
        if filename.lower().endswith(".png"):
            image_path = os.path.join(image_dir, filename)
            xmp_path = f"{image_path}.gq.xmp"

            if os.path.exists(xmp_path):
                print(f"Warning: {xmp_path} already exists and will be overwritten.")
                os.remove(xmp_path)  # Force overwrite

            tiff_digest = compute_native_digest(image_path, tiff_only=True)
            exif_digest = compute_native_digest(image_path, tiff_only=False)

            command = [
                "exiftool",
                "-XMP:CreateDate=now",
                "-XMP:Rating=1",
                "-XMP-dc:Description=Geeqie XMP generated by xmp4geeqie v" + SCRIPT_VERSION,
                "-XMP-tiff:NativeDigest=" + tiff_digest,  # Set TIFF NativeDigest
                "-XMP-exif:NativeDigest=" + exif_digest,  # Set EXIF NativeDigest
                "-overwrite_original",  # Ensure file is modified, not recreated
                xmp_path
            ]

            try:
                subprocess.run(command, check=True)
                print(f"✅ XMP file created for {filename}")
                print(f"   → TIFF NativeDigest: {tiff_digest}")
                print(f"   → EXIF NativeDigest: {exif_digest}")
            except subprocess.CalledProcessError as e:
                print(f"❌ Error processing {filename}: {e}")

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python xmp4geeqie.py <image_directory>")
        sys.exit(1)

    image_directory = sys.argv[1]
    generate_xmp_files(image_directory)
